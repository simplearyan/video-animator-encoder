<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Data Animator - Export</title>
    <!-- <script src="script.js"></script> -->
    <style>
        :root {
            --bg: #0F172A; --surface: #1E293B; --primary: #38BDF8; --text: #F8FAFC;
        }
        body { background: var(--bg); color: var(--text); font-family: 'Inter', sans-serif; margin: 0; padding: 20px; }
        .canvas-container { width: 100%; max-width: 600px; margin: 0 auto; border-radius: 12px; overflow: hidden; background: #000; aspect-ratio: 16/9; position: relative; }
        canvas { width: 100%; height: 100%; display: block; }
        .controls { display: grid; gap: 10px; margin-top: 20px; max-width: 600px; margin-inline: auto; }
        select, button { padding: 12px; border-radius: 8px; border: none; font-size: 1rem; cursor: pointer; }
        select { background: var(--surface); color: var(--text); }
        button { background: var(--primary); color: var(--bg); font-weight: bold; }
        .progress-bar { height: 6px; background: var(--surface); border-radius: 3px; margin-top: 10px; overflow: hidden; display: none; }
        .progress-fill { height: 100%; background: var(--primary); width: 0%; transition: width 0.1s; }
    </style>
</head>
<body>
    <div class="canvas-container">
        <canvas id="previewCanvas" width="1920" height="1080"></canvas>
    </div>

    <div class="controls">
        <label>Select Format:</label>
        <select id="muxerType">
            <option value="mp4">MP4 (Standard - Fast)</option>
            <option value="webm">WebM (Transparent/Open - Fast)</option>
            <option value="ffmpeg">FFmpeg (Professional - Slowest)</option>
        </select>
        <button id="exportBtn">Export 1080p Video</button>
        <div class="progress-bar" id="progressBar"><div class="progress-fill" id="progressFill"></div></div>
    </div>
</body>


<script>
    /**
 * PRO DATA ANIMATOR - CORE LOGIC
 * Features: 60FPS Preview + WebCodecs 1080p Export
 */

const canvas = document.getElementById('previewCanvas');
const ctx = canvas.getContext('2d');
const exportBtn = document.getElementById('exportBtn');
const muxerTypeSelect = document.getElementById('muxerType');
const progressFill = document.getElementById('progressFill');
const progressBar = document.getElementById('progressBar');

// Configuration
const VIDEO_WIDTH = 1920;
const VIDEO_HEIGHT = 1080;
const FPS = 30;
const DURATION_SECONDS = 5;
const TOTAL_FRAMES = FPS * DURATION_SECONDS;

let previewFrame = 0;
let isExporting = false;

// --- PART 1: PREVIEW ANIMATION LOOP ---
// Runs at 60fps regardless of export settings
function animatePreview() {
    if (!isExporting) {
        drawFrame(previewFrame, canvas.width, canvas.height);
        previewFrame++;
    }
    requestAnimationFrame(animatePreview);
}

/**
 * THE RENDERER: Shared drawing logic for both preview and export.
 * Ensures "What You See Is What You Get."
 */
function drawFrame(frameIndex, width, height) {
    // 1. Clear & Background
    ctx.fillStyle = '#0F172A';
    ctx.fillRect(0, 0, width, height);

    // 2. Animated Object (Moving Orb)
    const time = frameIndex * 0.05;
    const x = width / 2 + Math.cos(time) * 300;
    const y = height / 2 + Math.sin(time * 0.8) * 150;
    
    // Glow Effect
    ctx.shadowBlur = 30;
    ctx.shadowColor = '#38BDF8';
    ctx.fillStyle = '#38BDF8';
    ctx.beginPath();
    ctx.arc(x, y, 60, 0, Math.PI * 2);
    ctx.fill();

    // 3. UI Overlay
    ctx.shadowBlur = 0;
    ctx.fillStyle = "white";
    ctx.font = "bold 50px Inter";
    ctx.textAlign = "center";
    ctx.fillText("PRO DATA ANIMATOR", width / 2, height / 2 + 10);
    
    ctx.font = "30px JetBrains Mono";
    ctx.fillStyle = "#94A3B8";
    ctx.fillText(`FRAME: ${frameIndex} | RESOLUTION: 1080p`, width / 2, height - 80);
}

// --- PART 2: OFFLINE EXPORT LOGIC ---
// Uses WebCodecs for frame-by-frame encoding
async function startExport() {
    isExporting = true;
    const type = muxerTypeSelect.value;
    
    // 1. Initialize Muxer (Requires mp4-muxer or webm-muxer library)
    let muxer;
    if (type === 'mp4') {
        muxer = new Mp4Muxer.Muxer({
            target: new Mp4Muxer.ArrayBufferTarget(),
            video: { codec: 'avc', width: VIDEO_WIDTH, height: VIDEO_HEIGHT },
            fastStart: 'in-memory'
        });
    } else {
        muxer = new WebMMuxer.Muxer({
            target: new WebMMuxer.ArrayBufferTarget(),
            video: { codec: 'V_VP9', width: VIDEO_WIDTH, height: VIDEO_HEIGHT }
        });
    }

    // 2. Initialize VideoEncoder
    const encoder = new VideoEncoder({
        output: (chunk, metadata) => muxer.addVideoChunk(chunk, metadata),
        error: (e) => console.error("Encoder Error:", e)
    });

    encoder.configure({
        codec: type === 'mp4' ? 'avc1.42E01E' : 'vp09.00.10.08',
        width: VIDEO_WIDTH,
        height: VIDEO_HEIGHT,
        bitrate: 8_000_000, // 8Mbps
        framerate: FPS
    });

    // 3. The Encoding Loop
    for (let i = 0; i < TOTAL_FRAMES; i++) {
        // Draw the specific frame to the high-res canvas
        drawFrame(i, VIDEO_WIDTH, VIDEO_HEIGHT);

        // Convert canvas to VideoFrame
        const frame = new VideoFrame(canvas, { 
            timestamp: (i * 1_000_000) / FPS // Microseconds
        });

        // Encode frame (Keyframe every 2 seconds)
        encoder.encode(frame, { keyFrame: i % (FPS * 2) === 0 });
        frame.close(); // Crucial: prevent memory leaks

        // Update UI
        const progress = (i / TOTAL_FRAMES) * 100;
        progressFill.style.width = `${progress}%`;

        // Small delay to keep the browser responsive
        if (i % 10 === 0) await new Promise(r => setTimeout(r, 1));
    }

    // 4. Finalize
    await encoder.flush();
    muxer.finalize();
    
    const { buffer } = muxer.target;
    downloadBlob(new Blob([buffer], { type: `video/${type}` }), `animation.${type}`);

    // Reset UI
    isExporting = false;
    progressBar.style.display = 'none';
}

// --- UTILS ---
function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
}

// --- EVENT LISTENERS ---
exportBtn.addEventListener('click', async () => {
    exportBtn.disabled = true;
    exportBtn.innerText = "Encoding...";
    progressBar.style.display = 'block';

    try {
        await startExport();
        exportBtn.innerText = "Export Finished!";
    } catch (err) {
        console.error(err);
        alert("Export failed. See console.");
    } finally {
        exportBtn.disabled = false;
        if (!isExporting) exportBtn.innerText = "Export 1080p Video";
    }
});

// Start Preview
animatePreview();
</script>

</html>